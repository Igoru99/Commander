# Общее описание программы
***
*Commander* - командная оболочка, создаваемая для операционной системы KolibriOS.
В отличие от имеющихся аналогов, данная программа предоставляет продвинутые возможности
для разработки скриптовых сценариев за счет использования языка **KolibriScript**.
# Язык KolibriScript
***
### Общее описание языка
Язык **KolibriScript** предназначен для выполнения различных команд в командной среде *Commander*.

Любая последовательность конструкций на язык **KolibriScript** называется скриптом.
Скрипт может быть представлен как одной строкой ввода (при работе в терминале), так и отдельным файлом с расширением «.ks».

В языке **KolibriScript** допускается использование данных двух типов: целочисленной значение (соответствует типу short языка программирования C), строковое значение (соответствует типу char* языка программирования C). Также неявно имеется логический тип данных, который выдается в результате выполнения логического выражения. Переменные не могут содержать логический тип данных.
Существует две версии переменных: глобальные и локальные. Глобальные сохраняются в отдельном файле и доступны из любого скрипта. Локальные переменные существуют только в рамках текущей сессии.
Под сессией понимается выполнение скриптов из файлов или выполнение последовательности команд в командной строке.

Результатов выполнения любого скрипта является строка или пустое выражение (void).

Язык **KolibriScript** поддерживает:
- переменные двух типов данных и двух типов видимости;
- метки – обозначение места, куда можно перейти по безусловному переходу;
- условия – поддерживаются цепочки условий, а также вложенные условия;
- безусловный переход к метке;
- перенаправление вывода;
- логические операции сравнения на равенство и неравенство, логическая операция «И», логическая операция «ИЛИ» с возможностью вложения;
- арифметические операции сложения и вычитания с возможностью вложения.
- выполнение команд с аргументами.
### Грамматика языка
Язык **KolibriScript** имеет следующую грамматику в нотации РБНФ:

*Скрипт = {Конструкция, [Разделитель, Конструкция]}, «\0».
Тело условия = {Конструкция, [Разделитель, Конструкция]}, Разделитель.
Разделитель = «\n» | «;».
Конструкция = Условие | Объявление переменной | Команда | Перенаправление вывода | Метка | Переход к метке.
Условие = Условие «if», { Условие «elif» }, [ Условие «else» ].
Объявление переменной = Объявление глобальной переменной | Объявление локальной переменной.
Команда = Название, {Аргумент, [Аргумент]}.
Перенаправление вывода = Из файла в вывод | Из файла в переменную | Из переменной в файл | Из команды в файл | Из команды в переменную.
Из файла в вывод = (Строка, Перенаправление вправо, «stdout») | («stdout», Перенаправление влево, Строка).
Из файла в переменную = (Строка, Перенаправление вправо, Название) | (Название, Перенаправление влево, Строка).
Из переменной в файл = (Строка, Перенаправление вправо, Название) | (Название, Перенаправление влево, Строка).
Из команды в файл = (Строка, Перенаправление влево, Команда) | (Команда, Перенаправление вправо, Строка).
Из команды в переменную = (Название, Перенаправление влево, Команда) | (Команда, Перенаправление вправо, Название).
Перенаправление влево = «<» | «<<».
Перенаправление вправо = «>» | «>>».
Метка = «:», Название.
Переход к метке = «to», Название.
Условие «if» = «if», Логическое выражение, «then», Тело условия, «end».
Условие «elif» = «elif», Логическое выражение, «then», Тело условия, «end».
Условие «else» = «else», Тело условия, «end».
Объявление глобальной переменной = «set», «$», Название, «=», Значение переменной.
Объявление глобальной переменной = «set», Название, «=», Значение переменной.
Значение переменной = Арифметическое выражение | Сложение строк.
Аргумент = Флаг | Параметр.
Логическое выражение = Логический операнд, [Логическая операция, Логический операнд].
Логический операнд = «(», Логическое выражение, «)» | Получение значения переменной | Число | Логическая константа.
Логическая константа = «true» | «false».
Логическая операция = «==» | «!=» | «&» | «|».
Арифметическое выражение = Арифметический операнд, {Арифметическая операция, Арифметический операнд}.
Арифметический операнд = «(», Арифметическое выражение, «)» | Получение значения переменной | Число.
Арифметическая операция = «+» | «-».
Получение значения переменной = «@», Название.
Сложение строк = Строковой операнд, {«+», Строковой операнд}.
Строковой операнд = Строка | Получение значения переменной.
Строка = «’», {Символ}, «’».
Символ = <Любой символ>.
Название = Буква, {Цифра | Буква}.
Флаг = «-», Буква, {Буква}.
Параметр = Строка | Получение значения переменной.
Число = [«+» | «-»] (Цифра | (Цифра без нуля, {Цифра})).
Цифра = «0» | Цифра без нуля.
Цифра без нуля = «1»-«9».
Буква = «a»-«z» | «A»-«Z» | «_».*

Обозначения:
*<Любой символ> - любой символ ASCII.*
### Семантические правила языка
Для языка доступны следующие семантические правила:

**Работа с переменными:**
- переменные одного и того же уровня видимости можно переопределять, задавая другое значение;
- нельзя назвать локальную/глобальную переменную именем другой глобальной/локальной переменной;
- переменные обязательно должны иметь какое-либо значение;
- нельзя присвоить переменной значение этой же переменной, пока она не будет инициализирована.

**Работа с логическими выражениями:**
- результатом выполнения логического выражения является логическая константа «true» или «false»;

**Работа с условиями:**
- если в качестве условия выступает один операнд:
    1. если операнд – логическая константа или логическое выражение, то ее значение принимается за значение выражения;
    2. если операнд – арифметическое выражение, то результатом логического выражения будет «true», если значение арифметического значения отлично от 0.

**Работа с арифметическими выражениями:**
- операндами арифметического выражения могут быть только числа и переменные, содержащие числа.

**Работа со сложением строк:**
- операндами операции сложения строк могут быть только строки и переменные, содержащие строки.

**Работа со строками:**
- строки представляют собой последовательности экранированных символов, то есть все символы, находящиеся внутри строки, не несут каких-либо управляющих инструкций.

**Работа с метками:**
- нельзя создать две метки с одинаковыми именами;
- метки и переходы по ним не работают в режиме интерактивного ввода.

### Примеры использования
*Пример 1. "Hello, world!"*

    echo ‘Hello, world!’

Вывод:

    Hello, world!

*Пример 2. Числа Фибоначчи*

    set count = 5
    set number1 = 0
    set number2 = 1
    set counter = 0
    :do
    if @counter != @count then
        set counter = @counter + 1
        if @counter == 1 then
            echo @number1
        end
        elif @counter == 2 then
            echo @number2
        end
    else
        set temp = @number1 + @number2
        set number1 = @number2
        set number2 = @temp
        end
    to do
    end
    echo ‘End’

Вывод:

    0
    1
    1
    2
    3
    End

*Пример 3. Вывод всех директорий, названия которых содержат цифры*

    set root = ‘/dirs/’
    set dirs_count = 0
    set dir_name = ‘’
    set index = 0
    set is_number = 0
    dc root > dirs_count
    dl root > ‘dirs.txt’
    :do
    if @index != @dirs_count then
        getL ‘dirs.txt’ @index > dir_name
        contain_number @dir_name > is_number
        if @is_number then
            echo @dir_name
        end
        set index = @index + 1
        to do
    end

Вывод:

    dir1
    dir2
    dir3

*Примечания:*
В примере 3 использовались команды командной оболочки:
- dc <путь к папке> - возвращает число папок по указанному пути (вывод: число);
- dl <путь к папке> - выдает список всех директорий по указанному пути (вывод: строка, содержащая названия всех папок, разделенных символом «\n»);
- getL <путь к файлу> <индекс строки> - читает строку файла по указанному символу (вывод: строка файла, за исключением символа «\n»);
- contain_number <строка> - проверяет строку на наличие цифр (вывод: 0 – если нет цифр, 1 – если есть цифры).